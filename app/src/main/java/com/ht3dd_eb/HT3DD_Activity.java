//----------------------------------------------------------------------------------
// Name:		HT3DD
// Author:		Seyed Hami Nourbakhsh (SHN)
// Company:		-
// Date:		26.Sept.2011
// Application  description:
//				This a application which use CV method to change the 3D scenario
//				generated by OpenGL-ES in such a form that the scenario is changed
//				to the position of the user's head position. It use a head tracking
//				algorithm from openCV to detect user's face.
//
// To do:		- 17.10.2011, status: 	Done (w1144):
//										Add menu items HT ON, HT OFF, Reset view,
//										front cam, rear cam,
//				- 17.10.2011, status: 	Done (w1144):
//										Make a more complicated scenario, add textures
//				- 17.10.2011, status: 	Done (w1149):
//										Add a interpolator to calculate values
//										between delivered one (currently, Build
//										average).
//				- 01.11.2011, status:	NOT STARTED:
//										Add HW accelerator to openGl (http://developer.android.com/guide/topics/graphics/hardware-accel.html)
//
// Modification history:	Who	Date		What
//							SHN	26.09.11	Initial version. First draft
//							SHN	26.11.11	Added functionality, especially
//											interpolation (Average), Z-usage, menu
//											items,
//							SHN	xx.12.11
//----------------------------------------------------------------------------------

package com.ht3dd_eb;

import java.util.Timer;
import java.util.TimerTask;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.app.Activity;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.opengl.GLSurfaceView;
import android.opengl.GLU;
import android.opengl.GLUtils;
import android.os.Bundle;
import android.text.BoringLayout.Metrics;
//import android.util.Log;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.WindowManager;

import org.opencv.android.BaseLoaderCallback;
import org.opencv.android.LoaderCallbackInterface;

public class HT3DD_Activity extends Activity {

	 private GLSurfaceView 		 mGLSurfaceView;
	 public Context				 mContext;
	 
	 private MenuItem            mItemHT_ON;
	 private MenuItem            mItemHT_OFF;
	 private MenuItem            mItem_RESET;
	 private MenuItem            mItem_z_on_off;
	 private MenuItem            mItem_IP_on_off;
	 private MenuItem            mItem_AV_on_off;
	 //private MenuItem			 mItem_LOG_on_off;
	 private MenuItem            mItemValue;
	 
	 public static int 			 mScrSizeX;
	 public static int 			 mScrSizeY;
	 public Display				 mD;
	 public WindowManager		 mW;
	 
	 public Metrics				 mMetrics;
	 public static boolean       min_HT_ON = true;
	 public static boolean       min_RESET = false;
	 public static boolean       min_z_on_off = true;  		// false = z calculation is OFF
	 public static boolean       min_IP_on_off = false;  	// false = Interpolation for HT values OFF
	 public static boolean       min_AV_on_off = false;  	// false = averaging for HT values OFF
	 public static boolean       min_Logs_on_off = false;  	// false = Logs are OFF
	 public static float         min_Value = 0.5f;
	 public static float         minFaceSize = 0.35f;		// relative face size to the height
	 
	 public static boolean		 mRendererReady;
	 
	 //shn, head tracking values here
	 //public Fd Fd_Thread;
	 public FdCvBase Fd_Thread;

//	 private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {
//		 @Override
//		 public void onManagerConnected(int status) {
//			 switch (status) {
//				 case LoaderCallbackInterface.SUCCESS: {
//					 //Log.i(TAG, "OpenCV loaded successfully");
//
//					 // Load native library after(!) OpenCV initialization
//					 System.loadLibrary("detection_based_tracker");
//				 }	 break;
//				 default:
//				 	{
//				 		super.onManagerConnected(status);
//					}break;
//			 }
//	 };

	 @Override
		 protected void onCreate(Bundle savedInstanceState) {        
			 super.onCreate(savedInstanceState);

			 mGLSurfaceView = new ThisSurfaceView(this);
			 setContentView(mGLSurfaceView);       
			 mGLSurfaceView.requestFocus();        
			 mGLSurfaceView.setFocusableInTouchMode(true);
			 mRendererReady = false;
			 
			 mW = getWindowManager();
//			 mD = mW.getDefaultDisplay();
//			 mScrSizeX = mD.getWidth(); 			// getWidth is not supported in API:15
//			 mScrSizeY = mD.getHeight();			// getHeight is not supported in API:15
			 DisplayMetrics metrics = this.getResources().getDisplayMetrics();
			 mScrSizeX = metrics.widthPixels;
			 mScrSizeY = metrics.heightPixels;

			 mContext = mGLSurfaceView.getContext();
			 //Fd_Thread = new FdCvBase(mContext);			//shn: this or mContext as input parameter. what is correct?

	 }    
	 
	 @Override    
		 protected void onResume() {        
			 // Ideally a game should implement onResume() and onPause()        
			 // to take appropriate action when the activity looses focus        
			 super.onResume();        
			 mGLSurfaceView.onResume();    
	 }    
	 
	 @Override    
		 protected void onPause() {       
			 // Ideally a game should implement onResume() and onPause()        
			 // to take appropriate action when the activity looses focus        
			 super.onPause();       
			 mGLSurfaceView.onPause();  
	 }    
	 
	 @Override    
	 	protected void onDestroy() {       

		 super.onDestroy();
		 Fd_Thread.releaseHT();
	 }
	 
	 //generate a menu
	 /**/
	 @Override
	    public boolean onCreateOptionsMenu(Menu menu) {
	        mItemHT_ON = menu.add("HT (ON)");
	        mItemHT_OFF = menu.add("HT OFF");
	        mItem_IP_on_off = menu.add("Interpolator ON/(OFF)");
	        mItem_AV_on_off = menu.add("Averaging ON/(OFF)");
	        //mItem_LOG_on_off = menu.add("Logging ON/(OFF)");
	        mItem_z_on_off = menu.add("Z Calc (ON)/OFF");
	        mItem_RESET = menu.add("RESET VIEW");
	        return true;
	 }

	 @Override
	    public boolean onOptionsItemSelected(MenuItem item) {
	        if (item == mItemHT_ON)
	        	min_HT_ON = true;
	        else if (item == mItemHT_OFF)
	        	min_HT_ON = false;
	        else if (item == mItemValue)
	            min_Value = 0.3f;
	        else if (item == mItem_IP_on_off)
	        	min_IP_on_off = !min_IP_on_off;
	        else if (item == mItem_AV_on_off)
	        	min_AV_on_off = !min_AV_on_off;
	        //else if (item == mItem_LOG_on_off)
		        //min_Logs_on_off = !min_Logs_on_off;
	        else if (item == mItem_z_on_off)
	        	min_z_on_off = !min_z_on_off;
	        else if (item == mItem_RESET)
	        	min_RESET = true;
	        return true;	      
	 }
	 
 }
 
 /* Implementation of scenario control routine.*/
 class ThisSurfaceView extends GLSurfaceView {   
	 
	 private static final String TAG = "Renderer: ";
	 public static int HT_SCREEN_X = 400;
	 public static int HT_SCREEN_Y = 215;
	 public static float F_C = 1.15f;						// Frustum const
	 public static int timerTick = 0;
	 
	 public float mRender_ht_x; 
	 public float mRender_ht_y;
	 public boolean mUseHT = false;
	 public boolean first_draw = true;
	 public boolean first_val = true;
	 
	 //private final float TOUCH_SCALE_FACTOR = 180.0f / 320;   
	 //private final float TRACKBALL_SCALE_FACTOR = 36.0f;  
	 private Timer mTimer;	 
	 private ObjRenderer mRenderer;
	 private float te_x;
	 private float te_y;
	 private float te_x_d1;    
	 private float te_y_d1;
	 private float ht_x_d1;    
	 private float ht_y_d1;
	 private float ht_z_d1;
	 private int   ft_temp_x; 			
	 private int   ft_temp_y;			
	 private int   ft_temp_z;			
	 private int   ft_temp_t;			
	 private int   ft_temp_dt;			
	 
	 private float BackTraceX = 0.0f;
	 private float BackTraceY = 0.0f;
	 private float BackTraceZ = 0.0f;
	 private float dx;
	 private float dy;
	 private float dz;
	 private static boolean new_ht_flag_d1 = false;		// new Head tracking value d1
	 private static boolean new_te_flag = false;		// new touch event value
	 private static boolean new_te_flag_d1 = false;		// new touch event value d1
	 private float ratio;
	 
	 public ThisSurfaceView(Context context) {        
		 super(context);        
		 mRenderer = new ObjRenderer();       
		 setRenderer(mRenderer);        
		 setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);    
		 
		 mTimer = new Timer();
		 mTimer.schedule (new mTimerTask(), 5, 5);
		 
		 //mPreviousX = HT3D_STEActivity.mScrSizeX / 2;
		 //mPreviousY = HT3D_STEActivity.mScrSizeY / 2;
		 new_ht_flag_d1 = GlobalVar.new_flag;

		 ht_x_d1 = ThisSurfaceView.HT_SCREEN_X/2;
		 ht_y_d1 = ThisSurfaceView.HT_SCREEN_Y/2;
		 ht_z_d1 = 0.0f;
	 }    //constructor 
	 
	 /*@Override 
	 public boolean onTrackballEvent(MotionEvent e) {        
			 mRenderer.mAngleX += e.getX() * TRACKBALL_SCALE_FACTOR;        
			 mRenderer.mAngleY += e.getY() * TRACKBALL_SCALE_FACTOR;        
			 requestRender();        return true;    
	 }    
	 */
	 
	 @Override 
	 public boolean onTouchEvent(MotionEvent e) {        
		 te_x = e.getX();        
		 te_y = e.getY();        
		 new_te_flag = !new_te_flag;
		 
		 if (!HT3DD_Activity.min_HT_ON)
		 {	 
			 switch (e.getAction()) 
			 {        
			 	case MotionEvent.ACTION_MOVE:
//					 dx = te_x - mPreviousX;       
//					 dy = te_y - mPreviousY;            	 
//					 mPreviousX = x;        
//					 mPreviousY = y;        
			 }
		 }  			 
		 return true;    
	 }    
	 
	 /*Timer to update the frames*/
	 class mTimerTask extends TimerTask {   
		 public void run() {       
			 requestRender();
			 timerTick ++;
		 }
	 }
	 	 
	 /* Render a object.*/    
	 private class ObjRenderer implements GLSurfaceView.Renderer {      
		 
		 private scenario mScen;   
		 //public float mAngleX;      
		 //public float mAngleY;  
		 
		 private int  		mTextureId;		
		 private int[] 		mTextures;
		 private Bitmap		mBmpTex_00;	
		 private Bitmap		mBmpTex_01;	
		 private Bitmap		mBmpTex_02;	
		 private Bitmap		mBmpTex_03;	
		 private float 		dx_frust = 0;
		 private float 		dy_frust = 0;
		 private float 		dz_frust = 0;
		 private int 		cnt;
		 private Mem		mM;						// interpolation of HT values
		 
		 private float[] 	posObj_0 = {			// new float[30][3];
				 -3.0f,  -2.0f,  -5.0f,				// most important transformation, draw with mBmpTex_00
				  3.0f,   0.0f,   0.0f,
				  3.0f,   0.0f,   0.0f,
				 -3.0f,   4.0f,   1.5f,
				 -7.0f,  -6.0f, -11.5f,
				 14.0f,   0.0f,   0.0f,
				  0.0f,   0.0f,  -9.0f,
				-14.0f,   0.0f,   0.0f,
				 };				 
				 
		 private float[] 	posObj_1 = {			// new float[30][3];
				  8.5f,   0.0f,  19.5f, 			// draw with mBmpTex_01
				 -3.0f,   0.0f,   0.0f,
				  1.5f,   2.0f,   1.0f,
				 -7.0f,   0.0f,  -4.0f,				
				  7.0f,   0.0f,   0.0f,
				  7.0f,   0.0f,   0.0f,
				  0.0f,  -2.0f,   1.0f,
				 -2.5f,   0.0f,   0.0f,
				 -9.0f,   0.0f,   0.0f,
				 -2.5f,   0.0f,   0.0f,
				  0.0f,   8.0f,  -5.0f,
				  7.0f,   0.0f,   0.0f,
				  7.0f,   0.0f,   0.0f,
				 -7.0f,  -4.0f,  -3.0f,
				  0.0f,   0.0f,  -4.0f,
				 };
		 
		 public ObjRenderer() {            
			 mScen = new scenario();
			 //mBmpTex_00 = BitmapFactory.decodeResource(getResources(), R.raw.marmor_256_256);
			 mBmpTex_00 = BitmapFactory.decodeResource(getResources(), R.drawable.marmor_256_256);
			 mBmpTex_01 = BitmapFactory.decodeResource(getResources(), R.raw.crate);
			 mM = new Mem();
		 } // constructor       
		 
		 public void onDrawFrame(GL10 gl) {            
			 
			 HT3DD_Activity.mRendererReady = true;

			 if (HT3DD_Activity.min_HT_ON)
			 {
				 
				 if (new_ht_flag_d1 != GlobalVar.new_flag)
				 {
					 
					 if (HT3DD_Activity.min_AV_on_off)
					 {
						 ft_temp_x = GlobalVar.x_g; 		//x value between 50 - 401
						 ft_temp_y = GlobalVar.y_g;			//y value between 50 - 215
						 ft_temp_z = GlobalVar.z_g;			//y value between 90 - 170	 
						 mM.nV(ft_temp_x, ft_temp_y, ft_temp_z, timerTick);
						 ft_temp_x = mM.aV[0]; 		
						 ft_temp_y = mM.aV[1];			
						 ft_temp_z = mM.aV[2];
						 ft_temp_t = mM.aV[3];
						 ft_temp_dt = mM.dt2av;
					 }
					 else if (HT3DD_Activity.min_IP_on_off)
					 {
						 ft_temp_x = GlobalVar.x_g; 		//x value between 50 - 401
						 ft_temp_y = GlobalVar.y_g;			//y value between 50 - 215
						 ft_temp_z = GlobalVar.z_g;			//y value between 90 - 170	 
						 mM.nV(ft_temp_x, ft_temp_y, ft_temp_z, timerTick);
						 ft_temp_x = (int)(mM.ax  + mM.bx * timerTick); 		
						 ft_temp_y = (int)(mM.ay  + mM.by * timerTick);			
						 ft_temp_z = (int)(mM.az  + mM.bz * timerTick);
					 }
					 else
					 {
						 ft_temp_x = GlobalVar.x_g; 		
						 ft_temp_y = GlobalVar.y_g;			
						 ft_temp_z = GlobalVar.z_g;				 
						 //ft_temp_dt = 50;
					 }
					 
					 dx = (ft_temp_x - ht_x_d1 );
					 dy = (ft_temp_y - ht_y_d1 );
					 dz = (ft_temp_z - ht_z_d1 );
					 
					 dx = dx / 20; 										// ov = 350
					 dy = -dy * ratio / 35; 							// ov = 350
					 dz = -dz / 90; 									// ov = 350
					 dx_frust = -(ft_temp_x - 200) / 143.0f;			// ov = 200, 2500
					 dy_frust = -(ft_temp_y - 110) * ratio / 140 ;		// ov = 110, 1400
					 					 
					 ht_x_d1 = ft_temp_x;        
					 ht_y_d1 = ft_temp_y; 
					 ht_z_d1 = ft_temp_z; 
					 
					 new_ht_flag_d1 = GlobalVar.new_flag;
//					 if (HT3D_STEActivity.min_Logs_on_off)
//					     Log.i(TAG, "HT::" + "Time= " + timerTick +  "; X= " + ht_x_d1 +  "; Y= " + ht_y_d1 +  "; Z= " + ht_z_d1);
//						 Log.i(TAG, "HT::" + "Time= " + timerTick + "; Delta Time= " + mM.dt2av +  "; Av-X= " + mM.aV[0] +  "; Av-Y= " + mM.aV[1] + "; Av-Z= " + mM.aV[2]+  "; Av-T= " + mM.aV[3]);
				 }
				 else														// Face detection is ON but we do not have new values
				 {
					 if (HT3DD_Activity.min_IP_on_off)
					 {
						 ft_temp_x = (int)(mM.ax  + mM.bx * timerTick); 		
						 ft_temp_y = (int)(mM.ay  + mM.by * timerTick);			
						 ft_temp_z = (int)(mM.az  + mM.bz * timerTick);
						 
						 dx = (ft_temp_x - ht_x_d1 );
						 dy = (ft_temp_y - ht_y_d1 );
						 dz = (ft_temp_z - ht_z_d1 );
						 
						 dx = dx / 20; 										// ov = 350
						 dy = -dy * ratio / 35; 							// ov = 350
						 dz = -dz / 90; 									// ov = 350
						 dx_frust = -(ft_temp_x - 200) / 143.0f;			// ov = 200, 2500
						 dy_frust = -(ft_temp_y - 110) * ratio / 140 ;		// ov = 110, 1400		
						 
						 ht_x_d1 = ft_temp_x;        
						 ht_y_d1 = ft_temp_y; 
						 ht_z_d1 = ft_temp_z; 
						 //Log.i(TAG, "HT::" + "Time= " + timerTick + "; Delta Time= " + mM.dt2av +  "; Av-X= " + mM.aV[0] +  "; Av-Y= " + mM.aV[1] + "; Av-Z= " + mM.aV[2]+  "; Av-T= " + mM.aV[3]);

					 }
					 else
					 {
						 dx = 0.0f;
						 dy = 0.0f;
						 dz = 0.0f;	 	 
					 }

				 }
			 }
			 else															// using the touch screen -> not using the face detection
			 {
				 dx = (te_x - te_x_d1) / 43;       	 				// ov=1500			//te_x value between 4 - 1275 	
				 dy = (te_y - te_y_d1 ) * ratio / 150;           	// ov=1500			//te_y value between -23 - 728	
				 dx_frust = (635 - te_x) / 300;						// ov=10500
				 dy_frust = (te_y - 375) * ratio / 600;				// ov=6000
				 
				 te_x_d1 = te_x;        
				 te_y_d1 = te_y;    
				 new_te_flag_d1 = new_te_flag;
				 //Log.i(TAG, "TE::" + "Time; " + timerTick +  "; X; " + mPreviousX +  "; Y; " + mPreviousY);
			 }			 
			 
			 BackTraceX = BackTraceX + dx;
			 BackTraceY = BackTraceY + dy;
			 BackTraceZ = BackTraceZ + dz;
			 //Log.i(TAG, "Time; " + timerTick +  "; X; " + mPreviousX +  "; Y; " + mPreviousY);
			 //Log.i(TAG, "Time; " + timerTick +  "; X; " + dx +  "; Y; " + dy);
			 //Log.i(TAG, "Time; " + timerTick +  "; X; " + dx_temp +  "; Y; " + dy_temp);
			 //Log.i(TAG, "mScrSizeX; " + HT3D_STEActivity.mScrSizeX +  "; mScrSizeY; " + HT3D_STEActivity.mScrSizeY );
			 
			 
//			 if (new_flag_d1 != GlobalVar.new_flag)
//			 {
//			     //Log.i(TAG, "Time; " + timerTick +  "; X; " + mPreviousX);
//			     new_flag_d1 = GlobalVar.new_flag;
//			 }
			 
			 /*Draw from here*/
			 if (HT3DD_Activity.min_RESET)
			 {
				 reset_view(gl);
				 HT3DD_Activity.min_RESET = false;
			 }

			 gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);            
			 gl.glMatrixMode(GL10.GL_MODELVIEW);            
			 	 

			 //Log.i(TAG, "Debug value for: posObj_0.length" + posObj_0.length );
			 
			 // ---Draw objects with the first texture
			 gl.glPushMatrix();
			 for (cnt = 0; cnt < (posObj_0.length)/3 ; cnt ++)
			 {
				 GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, mBmpTex_00, 0);
				 gl.glTranslatef( posObj_0[cnt*3], posObj_0[cnt*3 + 1], posObj_0[cnt*3 + 2]);  
				 mScen.objDraw(gl);  	
			 }
			 
			 // ---Draw objects with the second texture
			 for (cnt = 0; cnt < (posObj_1.length)/3 ; cnt++ )
			 {
				 GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, mBmpTex_01, 0);
				 gl.glTranslatef( posObj_1[cnt*3], posObj_1[cnt*3 + 1], posObj_1[cnt*3 + 2]);  
				 mScen.objDraw(gl);  			 
			 }
			 gl.glPopMatrix();
			 
			 // ---Draw the grid around the scenario
			 gl.glPushMatrix();
			 gl.glTranslatef( 0.0f, 0.0f, -3.0f);  
			 mScen.gridDraw(gl);  
			 for (cnt = 0; cnt < 20; cnt ++)
			 {
				 gl.glTranslatef( -0.0f, -0.0f, -1.0f);          				
				 mScen.gridDraw(gl);  
			 } 	 
			 gl.glPopMatrix();
			 
			 // ---Viewer position: Change the object setting in the scenario
			 if (!HT3DD_Activity.min_z_on_off)
				 dz = 0.0f;
			 GLU.gluLookAt(gl, -dx, dy, dz, -dx, dy, dz-100.0f, 0.0f, 1.0f, 0.0f);
			 
			 // ---Perspective: Change the perspective of the scenario
			 gl.glMatrixMode(GL10.GL_PROJECTION);            
			 gl.glLoadIdentity();
 			 gl.glFrustumf((-F_C-dx_frust)*ratio, (F_C-dx_frust)*ratio, -F_C-dy_frust, F_C-dy_frust, 1, 100  ); 
	          
		 } //onDrawFrame     
		
		 public void onSurfaceChanged(GL10 gl, int width, int height) {             
			 gl.glViewport(0, 0, width, height);                       
			 
			 ratio = (float) width / height;         
			 gl.glMatrixMode(GL10.GL_PROJECTION);          
			 gl.glLoadIdentity();           
			 gl.glFrustumf(-F_C*ratio, F_C*ratio, -1, 1, 1, 100);    //shn:reduce the deep information to a min
			 gl.glMatrixMode(GL10.GL_MODELVIEW);            
			 gl.glLoadIdentity();       
		 } //onSurfaceChanged       
		 
		 public void onSurfaceCreated(GL10 gl, EGLConfig config) {            
			      
			 gl.glDisable(GL10.GL_DITHER);            
			      
			 gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, GL10.GL_FASTEST);         
			 
			 gl.glClearColor(0.3f,0.3f,0.3f,1.0f); 							// Set background  
			 gl.glEnable(GL10.GL_CULL_FACE);  					// 
			 gl.glShadeModel(GL10.GL_SMOOTH);           		// Enable smooth shading,   
			 gl.glEnable(GL10.GL_DEPTH_TEST);      				// Don't know really what this is doing
			 
		     float fogColor[] = { 0.3f, 0.3f, 0.3f, 1.0f }; 
		     gl.glFogf(GL10.GL_FOG_MODE, GL10.GL_EXP);;                  
			 gl.glFogfv(GL10.GL_FOG_COLOR, fogColor, 0);                  
			 gl.glFogf(GL10.GL_FOG_DENSITY, 0.07f);                  
			 gl.glHint(GL10.GL_FOG_HINT, GL10.GL_DONT_CARE);                  
			 gl.glFogf(GL10.GL_FOG_START, 1.0f);                  
			 gl.glFogf(GL10.GL_FOG_END, 40.0f);                  
			 gl.glEnable(GL10.GL_FOG); 
			 
			 mTextures = new int[4];
			 gl.glGenTextures(1, mTextures, 0);
			 mTextureId = mTextures[0];	
			 gl.glEnable(GL10.GL_TEXTURE_2D); 					// 
			 gl.glBindTexture(GL10.GL_TEXTURE_2D, mTextureId);
			 gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER,	GL10.GL_LINEAR);
			 gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);
			 gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, GL10.GL_CLAMP_TO_EDGE);
			 gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, GL10.GL_REPEAT);
			 GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, mBmpTex_00, 0);
		 } // onSurfaceCreated   
		 
		 private void reset_view(GL10 gl){
			 dx = 0;
			 dy = 0;
			 dz = 0;
			 te_x_d1 = HT3DD_Activity.mScrSizeX/2;
			 te_y_d1 = HT3DD_Activity.mScrSizeY/2;
			 ht_x_d1 = HT_SCREEN_X/2;
			 ht_y_d1 = HT_SCREEN_Y/2;
			 ht_z_d1 = 0;
			 gl.glMatrixMode(GL10.GL_PROJECTION);           
			 gl.glTranslatef( -BackTraceX, -BackTraceY, -0.0f);          
			 gl.glFrustumf(-1*ratio, 1*ratio, -1, 1, 1, 100);    //shn:reduce the deep information to a min
			 gl.glMatrixMode(GL10.GL_MODELVIEW);            
			 gl.glLoadIdentity();       
		 	 BackTraceX= 0.0f;
		 	 BackTraceY= 0.0f;
		 	 BackTraceZ= 0.0f;
		 } // reset_view
	 }  // GLSurfaceView.Renderer   
} //GLSurfaceView